# Precedence theory
p0: precedes(?a,?b) => -precedes(?b,?a)
p1: precedes(?a,?b), precedes(?b,?c) => precedes(?a,?c)

# Narration theory
#     unless info to the contrary, discourse related clauses a and b are in a narration relation
n0: discourseDirectConnection(?a, ?b) => narration(?a, ?b)
#     Axiom of Narration: if two expressions in narration, the events they express form a sequence
n1: narration(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => precedes(?e,?f)
#     Contrapositive axiom of narration. Needed because the prop. defeasible logic of Nute will not automatically do contrapositive reasoning, but this seems required by the Asher-Lascarides examples.
n2: -precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -narration(?a,?b)
n2 > n0

# Explanation theory
#     clauses that are linked by a discourse relation and which express causally connected events are connected via explanation
e0: discourseDirectConnection(?a, ?b), hasEvent(?a,?e), hasEvent(?b,?f), causes(?f,?e) => explanation(?a,?b)
#     Axiom of Explanation: if explanation, then associated events are in an appropriate precedence relation
e1: explanation(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => -precedes(?e,?f)
#     Contrapositive axiom of explanation
e2: precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -explanation(?a,?b)

# Elaboration theory
#     clauses that are linked by a discourse relation and which express events where one prepares the other are connected via elaboration
el0: discourseDirectConnection(?a, ?b), hasEvent(?a,?e), hasEvent(?b,?f), prepares(?f,?e) => elaboration(?a,?b)
#     Axiom of Elaboration: if explanation, then associated events are in an appropriate precedence relation
el1: elaboration(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => -precedes(?e,?f)
#     Contrapositive axiom of elaboration
el2: precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -elaboration(?a,?b)

# Causation theory (general)
# Option 1: this could be potentially automatically generated by adding some types to the theory, e.g. that causes is a more specific kind of precedes and therefore overrides some precedes rules
#c0: causes(?e,?f) => precedes(?e,?f)
#c0 > p0
# Option 2: this is what is actually in the Asher-Lascarides paper, which is the softer principle that effects do not precede their causes. A bit trickier to automatically come out of the formalism
c0: causes(?e,?f) => -precedes(?f,?e)
c0 > n1

# Preparation theory (general)
# Option 1: this could be potentially automatically generated by adding some types to the theory, e.g. that prepares is a more specific kind of precedes and therefore overrides some precedes rules
#pr0: prepares(?e,?f) => precedes(?e,?f)
#pr0 > p0
# Similar to causation. We take option 2 here but again the stronger option 1 would also be possible.
pr0: prepares(?e,?f) => -precedes(?f,?e)
pr0 > n1

# Forced motion theory (general)
fm0: motion(?e), forceApplication(?f), hasAgent(?e,?x), hasPatient(?f,?x), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => causes(?f,?e)

# Pushing and falling as specific kinds of events
fall: hasAction(?e,fall) => motion(?e)
push: hasAction(?e,push) => forceApplication(?e)

# Prerequisite resource production theory (general)
res0: hasResource(?e,?r), hasResult(?f,?r), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => prepares(?f,?e)

# A bridge is a structure
bridge: bridge(?x) => structure(?x)
# Building a structure needs a plan as a resource. Drawing up a plan (for the structure) is a way to create it.
#     Note: silkie does not use "existential rules", and so from a sentence "Mark built the bridge" there is no way to insert a new entity, e.g. the plans.
#     However, if we know more of the context of the sentence, we have more ways to insert such an entity.
buildNeedsPlan: hasAction(?e,build), hasPatient(?e,?x), structure(?x), hasEvent(?a,?e), discourseDirectConnection(?a,?b), hasEvent(?b,?f), hasResult(?f,?p), plan(?p), designFor(?p,?x) => hasResource(?e,?p)
# Default assumption: if a structure and a plan are mentioned in discourse-connected clauses, the plan and structure are connected.
connectStructureAndPlan: hasPatient(?e,?x), structure(?x), hasResult(?f,?p), plan(?p), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => designFor(?p, ?x)

