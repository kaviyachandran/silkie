# Precedence theory
p0: precedes(?a,?b) => -precedes(?b,?a)
p1: precedes(?a,?b), precedes(?b,?c) => precedes(?a,?c)

# Overlap theory
o0: overlap(?e,?f) => overlap(?f,?e)
o0c: -overlap(?e,?f) => -overlap(?f,?e)
o1: overlap(?e,?f) => -precedes(?e,?f)
op: precedes(?e,?f) => -overlap(?e,?f)

# Narration theory
#     unless info to the contrary, discourse related clauses a and b are in a narration relation
n0: discourseDirectConnection(?a, ?b) => narration(?a, ?b)
#     Axiom of Narration: if two expressions in narration, the events they express form a sequence
n1: narration(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => precedes(?e,?f)
#     Contrapositive axiom of narration. Needed because the prop. defeasible logic of Nute will not automatically do contrapositive reasoning, but this seems required by the Asher-Lascarides examples.
n2: -precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -narration(?a,?b)
n2 > n0

# Explanation theory
#     clauses that are linked by a discourse relation and which express causally connected events are connected via explanation
e0: discourseDirectConnection(?a, ?b), hasEvent(?a,?e), hasEvent(?b,?f), causes(?f,?e) => explanation(?a,?b)
#     Axiom of Explanation: if explanation, then associated events are in an appropriate precedence relation
e1: explanation(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => -precedes(?e,?f)
#     Contrapositive axiom of explanation
e2: precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -explanation(?a,?b)

# Elaboration theory
#     clauses that are linked by a discourse relation and which express events where one prepares the other are connected via elaboration
el0: discourseDirectConnection(?a, ?b), hasEvent(?a,?e), hasEvent(?b,?f), prepares(?f,?e) => elaboration(?a,?b)
#     Axiom of Elaboration: if explanation, then associated events are in an appropriate precedence relation
el1: elaboration(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => -precedes(?e,?f)
#     Contrapositive axiom of elaboration
el2: precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -elaboration(?a,?b)

# Background (discouse relation) theory
#     state overlap: clauses that are linked by a discourse relation where the second one is a state describe overlapping events
bg0: discourseDirectConnection(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f), state(?f) => overlap(?e,?f)
#     Note: we want to defeat the default assumption that events described in sequence also occur in sequence. Pushing this all the way to the overlap theory however seems to assert general overlap too much power (why wouldn't general precedes be stronger?). Otoh, if we have more evidence from the text we can defeat the default assumption
bg0p: discourseDirectConnection(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f), state(?f) => -precedes(?e,?f)
bg0p > n1
#     overlap between described events indicates a background relation
bg1: discourseDirectConnection(?a,?b), overlap(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => background(?a,?b)
#     Axiom of Background: if clauses describing events are in a Background relation, described events overlap
bg2: background(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => overlap(?e,?f)
#     Contrapositive axiom of Background: if described events do not overlap, the clauses describing them are not in a Background relation
bg2: -overlap(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -background(?a,?b)

# Result (discourse relation) theory
#     result: if two related descriptions are about causally connected events, they are in a result relation
rs0: discourseDirectConnection(?a,?b), causes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => result(?a,?b)
rs0 > rs2
#     Axiom of Result: if two descriptions are in the result relation, then the events they describe are in a precedence relation
rs1: result(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => precedes(?e,?f)
rs1 > bg0p
rs1no: result(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f) => -overlap(?e,?f)
rs1no > o0
rs1no > bg0
rs1no > bg2
#     Contrapositive axiom of result: if two events are not in a precedence relation, then their descriptions are not in a result relation
rs2: -precedes(?e,?f), hasEvent(?a,?e), hasEvent(?b,?f) => -result(?a,?b)


# Causation theory (general)
# Option 1: this could be potentially automatically generated by adding some types to the theory, e.g. that causes is a more specific kind of precedes and therefore overrides some precedes rules
#c0: causes(?e,?f) => precedes(?e,?f)
#c0 > p0
# Option 2: this is what is actually in the Asher-Lascarides paper, which is the softer principle that effects do not precede their causes. A bit trickier to automatically come out of the formalism
c0: causes(?e,?f) => -precedes(?f,?e)
c0 > n1

# Preparation theory (general)
# Option 1: this could be potentially automatically generated by adding some types to the theory, e.g. that prepares is a more specific kind of precedes and therefore overrides some precedes rules
#pr0: prepares(?e,?f) => precedes(?e,?f)
#pr0 > p0
# Similar to causation. We take option 2 here but again the stronger option 1 would also be possible.
pr0: prepares(?e,?f) => -precedes(?f,?e)
pr0 > n1

# Forced motion theory (general)
fm0: motion(?e), forceApplication(?f), hasAgent(?e,?x), hasPatient(?f,?x), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => causes(?f,?e)

# Pushing and falling as specific kinds of events
fall: hasAction(?e,fall) => motion(?e)
push: hasAction(?e,push) => forceApplication(?e)

# Switching off a lamp causes darkness
switchoff: hasAction(?e,switchOff), hasPatient(?e,?l), light(?l), hasAction(?f,propertyAscription), hasRange(?f,dark), hasDomain(?f,?s), structure(?s), locatedIn(?l,?s) => causes(?e,?f)
lamplocation: discourseDirectConnection(?a,?b), hasEvent(?a,?e), hasEvent(?b,?f), hasPatient(?e,?l), hasDomain(?f,?s), light(?l), structure(?s) => locatedIn(?l,?s)

# Property ascriptions are states
hasAction(?e,propertyAscription) => state(?e)

# Prerequisite resource production theory (general)
res0: hasResource(?e,?r), hasResult(?f,?r), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => prepares(?f,?e)

# A bridge is a structure; so is a room
bridge: bridge(?x) => structure(?x)
room: room(?x) => structure(?x)

# Building a structure needs a plan as a resource. Drawing up a plan (for the structure) is a way to create it.
#     Note: silkie does not use "existential rules", and so from a sentence "Mark built the bridge" there is no way to insert a new entity, e.g. the plans.
#     However, if we know more of the context of the sentence, we have more ways to insert such an entity.
buildNeedsPlan: hasAction(?e,build), hasPatient(?e,?x), structure(?x), hasEvent(?a,?e), discourseDirectConnection(?a,?b), hasEvent(?b,?f), hasResult(?f,?p), plan(?p), designFor(?p,?x) => hasResource(?e,?p)
# Default assumption: if a structure and a plan are mentioned in discourse-connected clauses, the plan and structure are connected.
connectStructureAndPlan: hasPatient(?e,?x), structure(?x), hasResult(?f,?p), plan(?p), hasEvent(?a,?e), hasEvent(?b,?f), discourseDirectConnection(?a,?b) => designFor(?p, ?x)

